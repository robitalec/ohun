funs <-grep("zzz|data|package", funs, invert = T, value = T)
l1 <- unlist(lapply(funs, function(x)
{  a <-  try(run.def.args(x), silent = T)
if(any(grep(arg1, a))) return(x)
}      ))
if(!is.null(arg2))
{l2 <- unlist(lapply(funs, function(x)
{  a <-  try(run.def.args(x), silent = T)
if(any(grep(arg2, a))) return(x)
}      ))
res <- intersect(l1, l2)
} else res <- l1
return(res)
}
# run default arguments
run.def.args2 <-function(FUN)
{
fm <- formals(FUN)
fm <- fm[sapply(fm, length) > 0 | sapply(fm, is.null)]
fm <- lapply(1:length(fm), function(x) paste(names(fm)[x], "=", fm[x]))
for(i in fm) try(eval(parse(text = i)), silent = T)
}
#find functions with specific arguments and text
find.arg.text <- function(arg1, arg2 = NULL, pattern) {
f1 <- find.text(pattern = pattern, fun.only = T)
f2 <- find.arg(arg1 = arg1, arg2 = arg2)
return(intersect(f1, f2))
}
#bid data set
big.seltab <- function(X, nrow = 100){
Y <- X[rep(1:nrow(X), ceiling(nrow/nrow(X)))[1:nrow],]
Y$selec <- 1:nrow(Y)
if(is_selection_table(Y) | is_extended_selection_table(Y))
attr(Y, "check.results") <- attr(X, "check.results")[rep(1:nrow(attr(X, "check.results")), ceiling(nrow/nrow(attr(X, "check.results"))))[1:nrow],]
attr(Y, "check.results")$selec <- 1:nrow(Y)
return(Y)
}
#write all wav files in lbh_selec_table
write.sound.files <- function(path = tempdir(), extensible = T, other.formats = FALSE, simulated = FALSE){
# setwd(path)
data(lbh1, package = "ohun")
data(lbh2, package = "ohun")
tuneR::writeWave(lbh1, file.path(tempdir(),  "lbh1.wav"), extensible = extensible) #save sound files
tuneR::writeWave(lbh2, file.path(tempdir(),  "lbh2.wav"), extensible = extensible) #save sound files
if (simulated){
# Creating vector for duration
durs <- rep(c(0.3, 1), 5)
# Creating simulated song
set.seed(12)
simulated_1 <- warbleR::simulate_songs(n = 10, durs = durs, freqs = 5, sig2 = 0.01, gaps = 0.5, harms = 1, bgn = 0.1, path = tempdir(), file.name = "simulated_1", selec.table = TRUE, shape = "cos", fin = 0.3, fout = 0.35, samp.rate = 18)
sim_2 <- sim_songs(n = 10, durs = durs, freqs = 5, sig2 = 0.01, gaps = 0.5, harms = 1, bgn = 0.1, path = tempdir(), file.name = "simulated_2", selec.table = TRUE, shape = "cos", fin = 0.3, fout = 0.35, samp.rate = 18, am.amps = c(1, 2, 3, 2, 0.1, 2, 3, 3, 2, 1))
sel_tab2 <- sel_tab1 <- simulated_1$selec.table
sel_tab2$sound.files <- gsub("_1", "_2", sel_tab2$sound.files)
sel_tab <- rbind(sel_tab1, sel_tab2)
return(sel_tab)
}
# if (other.formats){
#   file.copy(from = system.file("extdata", "recording_20170716_230503.wac", package = "bioacoustics"), to = file.path(tempdir(), "recording_20170716_230503.wac"))
#
# file.copy(from = "../Phae.long4.mp3", to = file.path(tempdir(),  "Phae.long4.mp3"))
#
#   file.copy(from = file.path(tempdir(), "Phae.long1.wav"), to = file.path(tempdir(), "Phae.long5.wav"))
#
# wav2flac(file.path(tempdir(), "Phae.long5.wav"))
#
# if (selection.table){
#
#   lbh_selec_table$sound.files <- as.character(lbh_selec_table$sound.files)
#
#   sub_tab <- lbh_selec_table[lbh_selec_table$sound.files %in% c("Phae.long1.wav", "Phae.long4.wav"), 1:7]
#
#   sub_tab$sound.files[sub_tab$sound.files == "Phae.long1.wav"] <- "Phae.long5.flac"
#
#     sub_tab$sound.files[sub_tab$sound.files == "Phae.long4.wav"] <- "Phae.long4.mp3"
#
#     # fix times
#      sub_tab$start[sub_tab$sound.files == "Phae.long4.mp3"] <- c(0.2085945, 1.5950019, 2.3057996)
#
#      sub_tab$end[sub_tab$sound.files == "Phae.long4.mp3"] <- c(0.3528653, 1.7287163, 2.4289576)
#
#
#     sub_tab <- rbind(sub_tab, data.frame(sound.files = "recording_20170716_230503.wac", channel = 1, selec = 1, start = 0.1, end = 0.3, bottom.freq = 2, top.freq = 10))
#
#     sub_tab <- rbind(sub_tab, lbh_selec_table[, 1:7])
#
#     sub_tab$format <-ifelse(grepl("flac$", sub_tab$sound.files), "flac", ifelse(grepl("mp3$", sub_tab$sound.files), "mp3", "wav"))
#
#
#     return(sub_tab)
# } else return(NULL)
# }
}
# run all warbleR fuctions
run.all <- function() invisible(lapply(list.files(pattern = "\\.R", path = "./R", full.names = T, all.files = T), function(x) try(source(x), silent = T)))
# run.all()
list.selection.table <- function(lbh_selec_table, path = tempdir())
{
crr.dr <- getwd()
on.exit(setwd(crr.dr))
if(!is.null(path)) setwd(path)
Xlist <- list()
Xlist$Xdf <- lbh_selec_table
Xlist$Xst <- selection_table(lbh_selec_table)
Xlist$Xest <- selection_table(lbh_selec_table, extended = T, confirm.extended = F)
lbh_selec_table$song <- as.numeric(lbh_selec_table$sound.files)
Xlist$Xestbs <- selection_table(X = lbh_selec_table, extended = T, by.song = "song", confirm.extended = F)
names(Xlist) <- c("DATA.FRAME", "SELECTION_TABLE", "EXTENDED_SELECTION_TABLE", "by.song.EXTENDED_SELECTION_TABLE")
return(Xlist)
}
bi_mats <- function(X, labels) {
# create empty matrix to store memebership matrix
mat <- matrix(nrow = ncol(X), ncol = ncol(X))
# add labels to row and col names
rownames(mat) <- colnames(mat) <- labels
# add 0 if same lek and 1 if else
out <- lapply(1:(length(labels) - 1), function(i){
sapply((i + 1):length(labels), function(j)
if (labels[i] == labels[j]) 0 else 1)
})
# add to mat
mat[lower.tri(mat)] <- unlist(out)
# retunr as distance matrix
return(as.dist(mat))
}
FUN <- "get_templates"
#run function
source(file.path("./R", paste0(FUN,".R")))
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
#remove images and sound files
rm.sf.img()
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
# EXAMPLES
# save wav file examples
write.sound.files()
data("lbh_reference")
list.files(tempdir(), pattern = ".wav")
template <- get_templates(reference = lbh_reference, n.sub.spaces =  3, path = tempdir())
reference = lbh_reference
n.sub.spaces =  3
path = tempdir()
plot = TRUE
color = "#21908C4D"
if (!is.null(acoustic.space))
if (nrow(reference) != nrow(acoustic.space))
stop2("'reference' and 'acoustic.space' must have the same number of columns")
is.null(acoustic.space)
spectral_parameters <- spectro_analysis(reference, path = path, ...)
# remove columns with NAs
spectral_parameters <-
spectral_parameters[, !vapply(spectral_parameters, anyNA, FUN.VALUE = logical(1))]
spectral_parameters <- spectro_analysis(reference, path = path)
# remove columns with NAs
spectral_parameters <-
spectral_parameters[, !vapply(spectral_parameters, anyNA, FUN.VALUE = logical(1))]
# get PCA
pca <-
stats::prcomp(spectral_parameters[, 2:27], scale. = TRUE)
# get variance by PC
variance_pca <- summary(pca)$importance
# print info
message2(color = "silver",x =
paste0(
"The first 2 principal components explained ",
round(variance_pca[3, 2], 2),
" of the variance"
)
)
# keep those as acoustic space
acoustic.space <- pca$x[, 1:2]
plot_labs <- c("PC1", "PC2")
space = acoustic.space
xlab = plot_labs[1]
ylab = plot_labs[2]
x <- rep(1, n.sub.spaces)
space <- space[, 1:2]
space <- data.frame(space)
space$...NROW <- seq_len(nrow(space))
# mean center
mean_dim1 <- mean(space[, 1])
mean_dim2 <- mean(space[, 2])
# center at 0
space[, 1] <-  space[, 1] - mean_dim1
space[, 2] <-  space[, 2] - mean_dim2
x <- c(0, cumsum(x)/sum(x))
dx <- diff(x)
nx <- length(dx)
radius <- 100
t2xy <- function(t) {
t2p <- 2 * pi * t + 0 * pi/180
list(x = radius * cos(t2p), y = radius * sin(t2p))
}
if (plot)
plot(space[, 1] + mean_dim1, space[, 2] + mean_dim2, pch = 20, cex = 2, col = color, xlab = xlab, ylab = ylab)
NX
nx
i <- 1
n <- max(2, floor(100 * dx[i])) # 100 equivalent to edges in pie()
P <- t2xy(seq.int(x[i], x[i + 1], length.out = n))
if (plot)
lines(c(P$x[1], 0) + mean_dim1, c(P$y[1], 0) + mean_dim2, lty = 3, col = "gray", lwd = 3)
pol_df <- data.frame(x = c(P$x, 0), y = c(P$y, 0))
poly <- sp::Polygons(list(sp::Polygon(pol_df)), ID = 1)
poly
spp <- sp::SpatialPolygons(list(poly))
spp
poly
library(sf)
install.packages("sf")
library(sf)
class(poly)
list(sp::Polygon(pol_df))
sf::st_as_sf(list(sp::Polygon(pol_df)))
sf::st_as_sf(sp::Polygon(pol_df))
sf::st_as_sf(pol_df)
View(pol_df)
head(pol_df)
st_as_sf(pol_df, coords = c("x", "y"),
crs = 32611)
spp
nrow(pol_df)
n
pol = st_polygon(
list(pol_df)
)
pol_df
class(pol_df)
pol = st_polygon(
list(as.matrix(pol_df))
)
st_polygon(as.matrix(pol_df))
pol_df
as.matrix(pol_df)
pol_df[nrow(pol_df),]
rbind(pol_df[nrow(pol_df),], pol_df)
pol_df_closed <- rbind(pol_df[nrow(pol_df),], pol_df)
pol_df_closed
st_polygon(as.matrix(pol_df_closed))
pol = st_polygon(
list(as.matrix(pol_df_closed))
)
spp
pol
class(pol)
class(poly)
str(pol)
sf::as_Spatial(pol)
sf::as_Spatial(pol)
polys <- lapply(1:nx, function(i){
n <- max(2, floor(100 * dx[i])) # 100 equivalent to edges in pie()
P <- t2xy(seq.int(x[i], x[i + 1], length.out = n))
if (plot)
lines(c(P$x[1], 0) + mean_dim1, c(P$y[1], 0) + mean_dim2, lty = 3, col = "gray", lwd = 3)
pol_df <- data.frame(x = c(P$x, 0), y = c(P$y, 0))
poly <- sp::Polygons(list(sp::Polygon(pol_df)), ID = 1)
spp <- sp::SpatialPolygons(list(poly))
# pol_df_closed <- rbind(pol_df[nrow(pol_df),], pol_df)
# pol = st_polygon(
#   list(as.matrix(pol_df_closed))
# )
#
#
return(spp)
}) else polys <- vector()
# get polygon for each sub space
if (n.sub.spaces > 1)
polys <- lapply(1:nx, function(i){
n <- max(2, floor(100 * dx[i])) # 100 equivalent to edges in pie()
P <- t2xy(seq.int(x[i], x[i + 1], length.out = n))
if (plot)
lines(c(P$x[1], 0) + mean_dim1, c(P$y[1], 0) + mean_dim2, lty = 3, col = "gray", lwd = 3)
pol_df <- data.frame(x = c(P$x, 0), y = c(P$y, 0))
poly <- sp::Polygons(list(sp::Polygon(pol_df)), ID = 1)
spp <- sp::SpatialPolygons(list(poly))
# pol_df_closed <- rbind(pol_df[nrow(pol_df),], pol_df)
# pol = st_polygon(
#   list(as.matrix(pol_df_closed))
# )
#
#
return(spp)
}) else polys <- vector()
polys
i
whch_within  <- which(!is.na(sp::over(x = sp::SpatialPoints(space[, 1:2]),  y = sp::SpatialPolygons(polys[[i]]@polygons), returnList = FALSE))) else whch_within <- seq_len(nrow(space))
if (i > 0)
whch_within  <- which(!is.na(sp::over(x = sp::SpatialPoints(space[, 1:2]),  y = sp::SpatialPolygons(polys[[i]]@polygons), returnList = FALSE))) else whch_within <- seq_len(nrow(space))
whch_within
pol
pts = st_sfc(st_point(c(.5,.5)), st_point(c(1.5, 1.5)), st_point(c(2.5, 2.5)))
pol = st_polygon(list(rbind(c(0,0), c(2,0), c(2,2), c(0,2), c(0,0))))
pol
(lst = st_intersects(pts, pol))
(lst = st_overlaps(pts, pol))
whch_within
pol
space[, 1:2]
sf::st_overlaps(space[, 1:2], pol)
st_point(c(.5,.5))
st_sfc
pts
st_sfc(st_point(space[, 1:2]))
st_point(space[, 1:2])
st_point(as.matrix(space[, 1:2]))
st_sfc((as.matrix(space[, 1:2])))
space[, 1:2]
pts
st_sfc(data.frame(space[, 1:2], geom=sfc))
st_sfc(data.frame(geom = space[, 1:2]))
st_sf(data.frame(geom = space[, 1:2]))
st_sf(data.frame(a = 1:nrow(space), geom = space[, 1:2]))
st_sf(data.frame(a = 1:nrow(space), geom = as.matrix(space[, 1:2])))
pt1 = st_point(c(0,1))
pt2 = st_point(c(1,1))
(sfc = st_sfc(pt1, pt2))
st_sfc(pt1, pt2)
d = st_sf(data.frame(a=1:2, geom=sfc))
class(d)
class(pts)
# the given data above
my.df <- read.table(text="
longitude    latitude
128.6979    -7.4197
153.0046    -4.7089
104.3261    -6.7541
124.9019    4.7817
126.7328    2.1643
153.2439    -5.6500
142.8673    23.3882
152.6890    -5.5710",
header=TRUE)
# Convert data frame to sf object
my.sf.point <- st_as_sf(x = my.df,
coords = c("longitude", "latitude"),
crs = "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")
class(my.sf.point)
my.df
# Convert data frame to sf object
my.sf.point <- st_as_sf(x = my.df,
coords = c("longitude", "latitude"))
my.sf.point <- st_as_sf(x = space[, 1:2],
coords = c("x", "y"))
space[, 1:2]
my.sf.point <- st_as_sf(x = data.frame(x = space[ , 1], y = space[ , 2]),
coords = c("x", "y"))
my.sf.point
pts <- st_as_sf(x = data.frame(x = space[ , 1], y = space[ , 2]),
coords = c("x", "y"))
sf::st_overlaps(pts, pol)
sp::over(x = sp::SpatialPoints(space[, 1:2]),  y = sp::SpatialPolygons(polys[[i]]@polygons), returnList = FALSE))
sp::over(x = sp::SpatialPoints(space[, 1:2]),  y = sp::SpatialPolygons(polys[[i]]@polygons), returnList = FALSE)
pol
pol = st_polygon(
list(as.matrix(pol_df_closed))
)
sf::st_overlaps(pts, pol)
pts
pol
pts <- st_as_sf(x = data.frame(x = space[ , 1], y = space[ , 2]),
coords = c("x", "y"))
sf::st_overlaps(pts, pol)
overlp
overlp <- sf::st_overlaps(pts, pol)
is.na(overlp)
sp::over(x = sp::SpatialPoints(space[, 1:2]),  y = sp::SpatialPolygons(polys[[i]]@polygons), returnList = FALSE))
sp::over(x = sp::SpatialPoints(space[, 1:2]),  y = sp::SpatialPolygons(polys[[i]]@polygons), returnList = FALSE)))
sp::over(x = sp::SpatialPoints(space[, 1:2]),  y = sp::SpatialPolygons(polys[[i]]@polygons), returnList = FALSE)
pts
pol
overlp <- sf::st_intersects(pts, pol)
overlp
which(overlp)
which(overlp == 1)
overlp
overlp[[1]]
str(overlp[[1]])
str(overlp)
overlp <- sf::st_intersects(pts, pol, sparse = FALSE)
overlp
overlp
which(overlp == 1)
whch_within
intrsect <- which(sf::st_intersects(pts, pol, sparse = FALSE) == 1)
whch_within <- which(sf::st_intersects(pts, pol, sparse = FALSE) == 1)
whch_within
sub_space <- space[whch_within, ]
# get centroid
centroid_coors <- colMeans(sub_space[, 1:2])
# and distance to centroid
dists_to_centroid <-
unlist(lapply(seq_len(nrow(sub_space)), function(x)
stats::dist(
rbind(sub_space[x, 1:2], centroid_coors)
)))
centroid <- sub_space$...NROW[which.min(dists_to_centroid)]
centroids[i + 1] <- centroid
source("~/Dropbox/R_package_testing/ohun/R/internal_functions.R")
source("~/Dropbox/R_package_testing/ohun/R/internal_functions.R")
template <- get_templates(reference = lbh_reference, n.sub.spaces =  3, path = tempdir())
source("~/Dropbox/R_package_testing/ohun/R/internal_functions.R")
template <- get_templates(reference = lbh_reference, n.sub.spaces =  3, path = tempdir())
source("~/Dropbox/R_package_testing/ohun/R/internal_functions.R")
template <- get_templates(reference = lbh_reference, n.sub.spaces =  3, path = tempdir())
polys <- lapply(1:nx, function(i){
n <- max(2, floor(100 * dx[i])) # 100 equivalent to edges in pie()
P <- t2xy(seq.int(x[i], x[i + 1], length.out = n))
if (plot)
lines(c(P$x[1], 0) + mean_dim1, c(P$y[1], 0) + mean_dim2, lty = 3, col = "gray", lwd = 3)
pol_df <- data.frame(x = c(P$x, 0), y = c(P$y, 0))
# poly <- sp::Polygons(list(sp::Polygon(pol_df)), ID = 1)
# spp <- sp::SpatialPolygons(list(poly))
pol_df_closed <- rbind(pol_df[nrow(pol_df),], pol_df)
poly <- st_polygon(
list(as.matrix(pol_df_closed))
)
return(poly)
}) else polys <- vector()
# get polygon for each sub space
if (n.sub.spaces > 1)
polys <- lapply(1:nx, function(i){
n <- max(2, floor(100 * dx[i])) # 100 equivalent to edges in pie()
P <- t2xy(seq.int(x[i], x[i + 1], length.out = n))
if (plot)
lines(c(P$x[1], 0) + mean_dim1, c(P$y[1], 0) + mean_dim2, lty = 3, col = "gray", lwd = 3)
pol_df <- data.frame(x = c(P$x, 0), y = c(P$y, 0))
# poly <- sp::Polygons(list(sp::Polygon(pol_df)), ID = 1)
# spp <- sp::SpatialPolygons(list(poly))
pol_df_closed <- rbind(pol_df[nrow(pol_df),], pol_df)
poly <- st_polygon(
list(as.matrix(pol_df_closed))
)
return(poly)
}) else polys <- vector()
polys
source("~/Dropbox/R_package_testing/ohun/R/internal_functions.R")
template <- get_templates(reference = lbh_reference, n.sub.spaces =  3, path = tempdir())
source("~/Dropbox/R_package_testing/ohun/R/internal_functions.R")
template <- get_templates(reference = lbh_reference, n.sub.spaces =  3, path = tempdir())
source("~/Dropbox/R_package_testing/ohun/R/internal_functions.R")
source("~/Dropbox/R_package_testing/ohun/R/internal_functions.R")
template <- get_templates(reference = lbh_reference, n.sub.spaces =  3, path = tempdir())
template <- get_templates(reference = lbh_reference, n.sub.spaces =  3, path = tempdir(), color = "red")
source("~/Dropbox/R_package_testing/ohun/R/internal_functions.R")
FUN <- "get_templates"
#run function
source(file.path("./R", paste0(FUN,".R")))
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
#remove images and sound files
rm.sf.img()
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
# EXAMPLES
# save wav file examples
write.sound.files()
data("lbh_reference")
list.files(tempdir(), pattern = ".wav")
template <- get_templates(reference = lbh_reference, n.sub.spaces =  3, path = tempdir())
# with custom acoustic space
spectral_parameters <- spectro_analysis(lbh_reference, path = tempdir())
# remove columns with NAs
spectral_parameters <- spectral_parameters[, !sapply(spectral_parameters, anyNA)]
# get PCA
pca <- stats::prcomp(spectral_parameters[, 2:27], scale. = TRUE)
template <- get_templates(reference = lbh_reference, n.sub.spaces =  3, acoustic.space = pca$x[, 1:2], path = tempdir())
template <- get_templates(reference = lbh_reference, n.sub.spaces =  3, acoustic.space = pca$x[, 1:2], path = tempdir())
template
# get PCA
pca <- stats::prcomp(spectral_parameters[, 2:6], scale. = TRUE)
template <- get_templates(reference = lbh_reference, n.sub.spaces =  3, acoustic.space = pca$x[, 1:2], path = tempdir())
# system("autoconf  ")
# usethis::use_rcpp()
# setwd("./warbleR/")
#delete NAMESPACE file
# Rcpp::compileAttributes()
#run document twice
# devtools::document(".")
# devtools::load_all()
# usethis::use_coverage()
# pkgcheck::use_github_action_pkgcheck()
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# devtools::run_examples( start = "rm_sil")
# devtools::build_manual()
# devtools::install()
# check in R version 3.X.X
## run in terminal:
# /opt/R/3.6.3/bin/R
# devtools::check("~/Dropbox/R_package_testing/warbleR/warbleR", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# system("autoconf  ")
# usethis::use_rcpp()
# setwd("./warbleR/")
#delete NAMESPACE file
# Rcpp::compileAttributes()
#run document twice
# devtools::document(".")
# devtools::load_all()
# usethis::use_coverage()
# pkgcheck::use_github_action_pkgcheck()
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# devtools::run_examples( start = "rm_sil")
# devtools::build_manual()
# devtools::install()
# check in R version 3.X.X
## run in terminal:
# /opt/R/3.6.3/bin/R
# devtools::check("~/Dropbox/R_package_testing/warbleR/warbleR", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
usethis::use_github_action("pkgdown")
