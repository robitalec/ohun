for (i in seq_len(nrow(ambiguous_overlaps)))
ovlp_mat[rownames(ovlp_mat) == ambiguous_overlaps$detection.id[i], colnames(ovlp_mat) ==  ambiguous_overlaps$reference.id[i]] <- ambiguous_overlaps$IoU[i]
# convert overlaps == 1 to 0.9999 (igraph ignores those equal to 1)
# org_ovlp_mat <- ovlp_mat
ovlp_mat[ovlp_mat >= 1] <- 0.99999
# convert to graph
ovlp_graph <-
igraph::graph_from_incidence_matrix(ovlp_mat)
#convert to data frame
df_ovlp_graph <- igraph::as_data_frame(ovlp_graph)
# add amount of overlap as weights
igraph::E(ovlp_graph)$weight <-
vapply(seq_len(nrow(df_ovlp_graph)), function(x)
ovlp_mat[df_ovlp_graph$from[x], df_ovlp_graph$to[x]], FUN.VALUE = numeric(1))
#
#   # plot just to troubleshoot
#   # plot.igraph(ovlp_graph, layout = layout_as_bipartite,
#   #             vertex.color=c("green","cyan")[V(ovlp_graph)$type+1], edge.width=(3*E(g)$weight), vertex.size = 40)
#
#   # get maximum bipartite graph
bigraph_results <-
igraph::max_bipartite_match(ovlp_graph)$matching
# keep only detection results
bigraph_results <-
bigraph_results[1:nrow(ovlp_mat)]
# keep only true positive overlaps
overlap_iou <- overlap_iou[overlap_iou$detection.id %in% names(bigraph_results)[!is.na(bigraph_results)] & overlap_iou$reference.id %in% bigraph_results | !overlap_iou$detection.id %in%  ambiguous_detec$id, ]
overlap_iou
# get those that change to false positives
bigraph_false_positives <-
names(bigraph_results)[is.na(bigraph_results)]
if (length(bigraph_false_positives) > 0)
sub_detec$detection.class[paste(sub_detec$sound.files, sub_detec$selec, sep = "-") %in% bigraph_false_positives] <- gsub("true.positive", "negative", sub_detec$detection.class[paste(sub_detec$sound.files, sub_detec$selec, sep = "-") %in% bigraph_false_positives])
any(grepl("true.positive", sub_detec$detection.class))
sub_detec$overlap <- vapply(seq_len(nrow(sub_detec)),
function(x){
ovlp <- overlap_iou$IoU[overlap_iou$detection.id == paste(sub_detec$sound.files[x], sub_detec$selec[x], sep = "-")]
if (length(ovlp) == 0) ovlp <- NA
return(ovlp)
},
FUN.VALUE = numeric(1))
# include overlaps as attributes
attributes(sub_detec)$overlaps <- overlap_iou
source("~/Dropbox/R_package_testing/ohun/R/label_detection.R")
source("~/Dropbox/R_package_testing/ohun/R/label_detection.R")
ld <- label_detection(reference = reference, detection = detection, min.overlap = 0.01)
z
z <- "2.wav"
# get subset from detection for that sound file
sub_detec <-
as.data.frame(detection[detection$sound.files == z,])
any(reference$sound.files == z)
# get subset from template for that sound file
sub_ref <-
as.data.frame(reference[reference$sound.files == z, ])
ovlp_events <- overlapping_detections(reference = sub_ref, detection = sub_detec)
overlap_iou <- pairs_iou(df = ovlp_events, detection = sub_detec, reference = sub_ref)
# filter detections below minimum overlap
overlap_iou <- overlap_iou[overlap_iou$IoU > min.overlap, ]
sub_detec$detection.class <- vapply(paste(sub_detec$sound.files, sub_detec$selec, sep = "-"), function(y){
# if no reference overlap is a false positive
if (sum(overlap_iou$detection.id == y) == 0) detection.class <- "false.positive"
# if only one overlapping reference is a true positive
if (sum(overlap_iou$detection.id == y) == 1) detection.class <-  "true.positive"
# if more than one overlapping reference is a merged true positive
if (sum(overlap_iou$detection.id == y) > 1) detection.class <-  "true.positive (merged)"
# if 1 reference overlaps and that reference overlaps with other detections
if (sum(overlap_iou$detection.id == y) == 1 & any(overlap_iou$reference.id[overlap_iou$detection.id != y] %in% overlap_iou$reference.id[overlap_iou$detection.id == y])) detection.class <- "true.positive (split)"
if (sum(overlap_iou$detection.id == y) > 1 & any(overlap_iou$reference.id[overlap_iou$detection.id != y] %in% overlap_iou$reference.id[overlap_iou$detection.id == y])) detection.class <- "true.positive (split/merged)"
return(detection.class)
}, FUN.VALUE = character(1))
# use maximum bipartite graph matching to solve ambiguous detections
if (any(grepl("split|merge", sub_detec$detection.class))) {
ambiguous_detec <- sub_detec[grepl("split|merge", sub_detec$detection.class), ]
ambiguous_detec$id <- paste(ambiguous_detec$sound.files, ambiguous_detec$selec, sep = "-")
sub_ref$id <- paste(sub_ref$sound.files, sub_ref$selec, sep = "-")
ambiguous_overlaps <- overlap_iou[overlap_iou$detection.id %in%  ambiguous_detec$id, ]
ambiguous_ref <- sub_ref[sub_ref$id %in% ambiguous_overlaps$reference.id, ]
# get matrix to find maximum bipartite graph
ovlp_mat <-
matrix(
rep(0, (
nrow(ambiguous_detec) * nrow(ambiguous_ref)
)),
ncol = nrow(ambiguous_ref),
dimnames = list(ambiguous_detec$id, ambiguous_ref$id)
)
#
# fill out with proportion of overlap for those in which overlap was already calculated
for (i in seq_len(nrow(ambiguous_overlaps)))
ovlp_mat[rownames(ovlp_mat) == ambiguous_overlaps$detection.id[i], colnames(ovlp_mat) ==  ambiguous_overlaps$reference.id[i]] <- ambiguous_overlaps$IoU[i]
# convert overlaps == 1 to 0.9999 (igraph ignores those equal to 1)
# org_ovlp_mat <- ovlp_mat
ovlp_mat[ovlp_mat >= 1] <- 0.99999
# convert to graph
ovlp_graph <-
igraph::graph_from_incidence_matrix(ovlp_mat)
#convert to data frame
df_ovlp_graph <- igraph::as_data_frame(ovlp_graph)
# add amount of overlap as weights
igraph::E(ovlp_graph)$weight <-
vapply(seq_len(nrow(df_ovlp_graph)), function(x)
ovlp_mat[df_ovlp_graph$from[x], df_ovlp_graph$to[x]], FUN.VALUE = numeric(1))
#
#   # plot just to troubleshoot
#   # plot.igraph(ovlp_graph, layout = layout_as_bipartite,
#   #             vertex.color=c("green","cyan")[V(ovlp_graph)$type+1], edge.width=(3*E(g)$weight), vertex.size = 40)
#
#   # get maximum bipartite graph
bigraph_results <-
igraph::max_bipartite_match(ovlp_graph)$matching
# keep only detection results
bigraph_results <-
bigraph_results[1:nrow(ovlp_mat)]
# keep only true positive overlaps
overlap_iou <- overlap_iou[overlap_iou$detection.id %in% names(bigraph_results)[!is.na(bigraph_results)] & overlap_iou$reference.id %in% bigraph_results | !overlap_iou$detection.id %in%  ambiguous_detec$id, ]
# get those that change to false positives
bigraph_false_positives <-
names(bigraph_results)[is.na(bigraph_results)]
if (length(bigraph_false_positives) > 0)
sub_detec$detection.class[paste(sub_detec$sound.files, sub_detec$selec, sep = "-") %in% bigraph_false_positives] <- gsub("true.positive", "negative", sub_detec$detection.class[paste(sub_detec$sound.files, sub_detec$selec, sep = "-") %in% bigraph_false_positives])
}
{
# get subset from template for that sound file
sub_ref <-
as.data.frame(reference[reference$sound.files == z, ])
ovlp_events <- overlapping_detections(reference = sub_ref, detection = sub_detec)
overlap_iou <- pairs_iou(df = ovlp_events, detection = sub_detec, reference = sub_ref)
# filter detections below minimum overlap
overlap_iou <- overlap_iou[overlap_iou$IoU > min.overlap, ]
sub_detec$detection.class <- vapply(paste(sub_detec$sound.files, sub_detec$selec, sep = "-"), function(y){
# if no reference overlap is a false positive
if (sum(overlap_iou$detection.id == y) == 0) detection.class <- "false.positive"
# if only one overlapping reference is a true positive
if (sum(overlap_iou$detection.id == y) == 1) detection.class <-  "true.positive"
# if more than one overlapping reference is a merged true positive
if (sum(overlap_iou$detection.id == y) > 1) detection.class <-  "true.positive (merged)"
# if 1 reference overlaps and that reference overlaps with other detections
if (sum(overlap_iou$detection.id == y) == 1 & any(overlap_iou$reference.id[overlap_iou$detection.id != y] %in% overlap_iou$reference.id[overlap_iou$detection.id == y])) detection.class <- "true.positive (split)"
if (sum(overlap_iou$detection.id == y) > 1 & any(overlap_iou$reference.id[overlap_iou$detection.id != y] %in% overlap_iou$reference.id[overlap_iou$detection.id == y])) detection.class <- "true.positive (split/merged)"
return(detection.class)
}, FUN.VALUE = character(1))
# use maximum bipartite graph matching to solve ambiguous detections
if (any(grepl("split|merge", sub_detec$detection.class))) {
ambiguous_detec <- sub_detec[grepl("split|merge", sub_detec$detection.class), ]
ambiguous_detec$id <- paste(ambiguous_detec$sound.files, ambiguous_detec$selec, sep = "-")
sub_ref$id <- paste(sub_ref$sound.files, sub_ref$selec, sep = "-")
ambiguous_overlaps <- overlap_iou[overlap_iou$detection.id %in%  ambiguous_detec$id, ]
ambiguous_ref <- sub_ref[sub_ref$id %in% ambiguous_overlaps$reference.id, ]
# get matrix to find maximum bipartite graph
ovlp_mat <-
matrix(
rep(0, (
nrow(ambiguous_detec) * nrow(ambiguous_ref)
)),
ncol = nrow(ambiguous_ref),
dimnames = list(ambiguous_detec$id, ambiguous_ref$id)
)
#
# fill out with proportion of overlap for those in which overlap was already calculated
for (i in seq_len(nrow(ambiguous_overlaps)))
ovlp_mat[rownames(ovlp_mat) == ambiguous_overlaps$detection.id[i], colnames(ovlp_mat) ==  ambiguous_overlaps$reference.id[i]] <- ambiguous_overlaps$IoU[i]
# convert overlaps == 1 to 0.9999 (igraph ignores those equal to 1)
# org_ovlp_mat <- ovlp_mat
ovlp_mat[ovlp_mat >= 1] <- 0.99999
# convert to graph
ovlp_graph <-
igraph::graph_from_incidence_matrix(ovlp_mat)
#convert to data frame
df_ovlp_graph <- igraph::as_data_frame(ovlp_graph)
# add amount of overlap as weights
igraph::E(ovlp_graph)$weight <-
vapply(seq_len(nrow(df_ovlp_graph)), function(x)
ovlp_mat[df_ovlp_graph$from[x], df_ovlp_graph$to[x]], FUN.VALUE = numeric(1))
#
#   # plot just to troubleshoot
#   # plot.igraph(ovlp_graph, layout = layout_as_bipartite,
#   #             vertex.color=c("green","cyan")[V(ovlp_graph)$type+1], edge.width=(3*E(g)$weight), vertex.size = 40)
#
#   # get maximum bipartite graph
bigraph_results <-
igraph::max_bipartite_match(ovlp_graph)$matching
# keep only detection results
bigraph_results <-
bigraph_results[1:nrow(ovlp_mat)]
# keep only true positive overlaps
overlap_iou <- overlap_iou[overlap_iou$detection.id %in% names(bigraph_results)[!is.na(bigraph_results)] & overlap_iou$reference.id %in% bigraph_results | !overlap_iou$detection.id %in%  ambiguous_detec$id, ]
# get those that change to false positives
bigraph_false_positives <-
names(bigraph_results)[is.na(bigraph_results)]
if (length(bigraph_false_positives) > 0)
sub_detec$detection.class[paste(sub_detec$sound.files, sub_detec$selec, sep = "-") %in% bigraph_false_positives] <- gsub("true.positive", "negative", sub_detec$detection.class[paste(sub_detec$sound.files, sub_detec$selec, sep = "-") %in% bigraph_false_positives])
}
} else{
# get subset from detection for that sound file
sub_detec <-
as.data.frame(detection[detection$sound.files == z,])
# if sound file is found in references
if (any(reference$sound.files == z))
{
# get subset from template for that sound file
sub_ref <-
as.data.frame(reference[reference$sound.files == z, ])
ovlp_events <- overlapping_detections(reference = sub_ref, detection = sub_detec)
overlap_iou <- pairs_iou(df = ovlp_events, detection = sub_detec, reference = sub_ref)
# filter detections below minimum overlap
overlap_iou <- overlap_iou[overlap_iou$IoU > min.overlap, ]
sub_detec$detection.class <- vapply(paste(sub_detec$sound.files, sub_detec$selec, sep = "-"), function(y){
# if no reference overlap is a false positive
if (sum(overlap_iou$detection.id == y) == 0) detection.class <- "false.positive"
# if only one overlapping reference is a true positive
if (sum(overlap_iou$detection.id == y) == 1) detection.class <-  "true.positive"
# if more than one overlapping reference is a merged true positive
if (sum(overlap_iou$detection.id == y) > 1) detection.class <-  "true.positive (merged)"
# if 1 reference overlaps and that reference overlaps with other detections
if (sum(overlap_iou$detection.id == y) == 1 & any(overlap_iou$reference.id[overlap_iou$detection.id != y] %in% overlap_iou$reference.id[overlap_iou$detection.id == y])) detection.class <- "true.positive (split)"
if (sum(overlap_iou$detection.id == y) > 1 & any(overlap_iou$reference.id[overlap_iou$detection.id != y] %in% overlap_iou$reference.id[overlap_iou$detection.id == y])) detection.class <- "true.positive (split/merged)"
return(detection.class)
}, FUN.VALUE = character(1))
# use maximum bipartite graph matching to solve ambiguous detections
if (any(grepl("split|merge", sub_detec$detection.class))) {
ambiguous_detec <- sub_detec[grepl("split|merge", sub_detec$detection.class), ]
ambiguous_detec$id <- paste(ambiguous_detec$sound.files, ambiguous_detec$selec, sep = "-")
sub_ref$id <- paste(sub_ref$sound.files, sub_ref$selec, sep = "-")
ambiguous_overlaps <- overlap_iou[overlap_iou$detection.id %in%  ambiguous_detec$id, ]
ambiguous_ref <- sub_ref[sub_ref$id %in% ambiguous_overlaps$reference.id, ]
# get matrix to find maximum bipartite graph
ovlp_mat <-
matrix(
rep(0, (
nrow(ambiguous_detec) * nrow(ambiguous_ref)
)),
ncol = nrow(ambiguous_ref),
dimnames = list(ambiguous_detec$id, ambiguous_ref$id)
)
#
# fill out with proportion of overlap for those in which overlap was already calculated
for (i in seq_len(nrow(ambiguous_overlaps)))
ovlp_mat[rownames(ovlp_mat) == ambiguous_overlaps$detection.id[i], colnames(ovlp_mat) ==  ambiguous_overlaps$reference.id[i]] <- ambiguous_overlaps$IoU[i]
# convert overlaps == 1 to 0.9999 (igraph ignores those equal to 1)
# org_ovlp_mat <- ovlp_mat
ovlp_mat[ovlp_mat >= 1] <- 0.99999
# convert to graph
ovlp_graph <-
igraph::graph_from_incidence_matrix(ovlp_mat)
#convert to data frame
df_ovlp_graph <- igraph::as_data_frame(ovlp_graph)
# add amount of overlap as weights
igraph::E(ovlp_graph)$weight <-
vapply(seq_len(nrow(df_ovlp_graph)), function(x)
ovlp_mat[df_ovlp_graph$from[x], df_ovlp_graph$to[x]], FUN.VALUE = numeric(1))
#
#   # plot just to troubleshoot
#   # plot.igraph(ovlp_graph, layout = layout_as_bipartite,
#   #             vertex.color=c("green","cyan")[V(ovlp_graph)$type+1], edge.width=(3*E(g)$weight), vertex.size = 40)
#
#   # get maximum bipartite graph
bigraph_results <-
igraph::max_bipartite_match(ovlp_graph)$matching
# keep only detection results
bigraph_results <-
bigraph_results[1:nrow(ovlp_mat)]
# keep only true positive overlaps
overlap_iou <- overlap_iou[overlap_iou$detection.id %in% names(bigraph_results)[!is.na(bigraph_results)] & overlap_iou$reference.id %in% bigraph_results | !overlap_iou$detection.id %in%  ambiguous_detec$id, ]
# get those that change to false positives
bigraph_false_positives <-
names(bigraph_results)[is.na(bigraph_results)]
if (length(bigraph_false_positives) > 0)
sub_detec$detection.class[paste(sub_detec$sound.files, sub_detec$selec, sep = "-") %in% bigraph_false_positives] <- gsub("true.positive", "negative", sub_detec$detection.class[paste(sub_detec$sound.files, sub_detec$selec, sep = "-") %in% bigraph_false_positives])
}
} else{
sub_detec$detection.class <- "false.positive"
overlap_iou <- data.frame(sound.files = vector(), detection.id  = vector(), reference.id  = vector(), IoU  = vector())
}
if (any(grepl("true.positive", sub_detec$detection.class))) {
sub_detec$overlap <- vapply(seq_len(nrow(sub_detec)),
function(x){
ovlp <- overlap_iou$IoU[overlap_iou$detection.id == paste(sub_detec$sound.files[x], sub_detec$selec[x], sep = "-")]
if (length(ovlp) == 0) ovlp <- NA
return(ovlp)
},
FUN.VALUE = numeric(1))
} else  sub_detec$overlap <- NA
# get subset from detection for that sound file
sub_detec <-
as.data.frame(detection[detection$sound.files == z,])
# if sound file is found in references
if (any(reference$sound.files == z))
# get subset from template for that sound file
sub_ref <-
as.data.frame(reference[reference$sound.files == z, ])
ovlp_events <- overlapping_detections(reference = sub_ref, detection = sub_detec)
overlap_iou <- pairs_iou(df = ovlp_events, detection = sub_detec, reference = sub_ref)
# filter detections below minimum overlap
overlap_iou <- overlap_iou[overlap_iou$IoU > min.overlap, ]
sub_detec$detection.class <- vapply(paste(sub_detec$sound.files, sub_detec$selec, sep = "-"), function(y){
# if no reference overlap is a false positive
if (sum(overlap_iou$detection.id == y) == 0) detection.class <- "false.positive"
# if only one overlapping reference is a true positive
if (sum(overlap_iou$detection.id == y) == 1) detection.class <-  "true.positive"
# if more than one overlapping reference is a merged true positive
if (sum(overlap_iou$detection.id == y) > 1) detection.class <-  "true.positive (merged)"
# if 1 reference overlaps and that reference overlaps with other detections
if (sum(overlap_iou$detection.id == y) == 1 & any(overlap_iou$reference.id[overlap_iou$detection.id != y] %in% overlap_iou$reference.id[overlap_iou$detection.id == y])) detection.class <- "true.positive (split)"
if (sum(overlap_iou$detection.id == y) > 1 & any(overlap_iou$reference.id[overlap_iou$detection.id != y] %in% overlap_iou$reference.id[overlap_iou$detection.id == y])) detection.class <- "true.positive (split/merged)"
return(detection.class)
}, FUN.VALUE = character(1))
ambiguous_detec <- sub_detec[grepl("split|merge", sub_detec$detection.class), ]
any(grepl("split|merge", sub_detec$detection.class))
ambiguous_detec <- sub_detec[grepl("split|merge", sub_detec$detection.class), ]
ambiguous_detec$id <- paste(ambiguous_detec$sound.files, ambiguous_detec$selec, sep = "-")
sub_ref$id <- paste(sub_ref$sound.files, sub_ref$selec, sep = "-")
ambiguous_overlaps <- overlap_iou[overlap_iou$detection.id %in%  ambiguous_detec$id, ]
ambiguous_ref <- sub_ref[sub_ref$id %in% ambiguous_overlaps$reference.id, ]
# get matrix to find maximum bipartite graph
ovlp_mat <-
matrix(
rep(0, (
nrow(ambiguous_detec) * nrow(ambiguous_ref)
)),
ncol = nrow(ambiguous_ref),
dimnames = list(ambiguous_detec$id, ambiguous_ref$id)
)
#
# fill out with proportion of overlap for those in which overlap was already calculated
for (i in seq_len(nrow(ambiguous_overlaps)))
ovlp_mat[rownames(ovlp_mat) == ambiguous_overlaps$detection.id[i], colnames(ovlp_mat) ==  ambiguous_overlaps$reference.id[i]] <- ambiguous_overlaps$IoU[i]
# convert overlaps == 1 to 0.9999 (igraph ignores those equal to 1)
# org_ovlp_mat <- ovlp_mat
ovlp_mat[ovlp_mat >= 1] <- 0.99999
# convert to graph
ovlp_graph <-
igraph::graph_from_incidence_matrix(ovlp_mat)
#convert to data frame
df_ovlp_graph <- igraph::as_data_frame(ovlp_graph)
# add amount of overlap as weights
igraph::E(ovlp_graph)$weight <-
vapply(seq_len(nrow(df_ovlp_graph)), function(x)
ovlp_mat[df_ovlp_graph$from[x], df_ovlp_graph$to[x]], FUN.VALUE = numeric(1))
#
#   # plot just to troubleshoot
#   # plot.igraph(ovlp_graph, layout = layout_as_bipartite,
#   #             vertex.color=c("green","cyan")[V(ovlp_graph)$type+1], edge.width=(3*E(g)$weight), vertex.size = 40)
#
#   # get maximum bipartite graph
bigraph_results <-
igraph::max_bipartite_match(ovlp_graph)$matching
# keep only detection results
bigraph_results <-
bigraph_results[1:nrow(ovlp_mat)]
# keep only true positive overlaps
overlap_iou <- overlap_iou[overlap_iou$detection.id %in% names(bigraph_results)[!is.na(bigraph_results)] & overlap_iou$reference.id %in% bigraph_results | !overlap_iou$detection.id %in%  ambiguous_detec$id, ]
overlap_iou
overlap_iou$detection.id %in% names(bigraph_results)[!is.na(bigraph_results)]
overlap_iou$detection.id %in% names(bigraph_results)[!is.na(bigraph_results)]
overlap_iou$reference.id %in% bigraph_results | !overlap_iou$detection.id %in%  ambiguous_detec$id
overlap_iou$reference.id
bigraph_results
overlap_iou
# add amount of overlap as weights
igraph::E(ovlp_graph)$weight <-
vapply(seq_len(nrow(df_ovlp_graph)), function(x)
ovlp_mat[df_ovlp_graph$from[x], df_ovlp_graph$to[x]], FUN.VALUE = numeric(1))
#
#   # plot just to troubleshoot
#   # plot.igraph(ovlp_graph, layout = layout_as_bipartite,
#   #             vertex.color=c("green","cyan")[V(ovlp_graph)$type+1], edge.width=(3*E(g)$weight), vertex.size = 40)
#
#   # get maximum bipartite graph
bigraph_results <-
igraph::max_bipartite_match(ovlp_graph)$matching
bigraph_results
# keep only detection results
bigraph_results <-
bigraph_results[1:nrow(ovlp_mat)]
bigraph_results
overlap_iou$detection.id
names(bigraph_results)[!is.na(bigraph_results)]
overlap_iou$reference.id %in% bigraph_results
paste(names(bigraph_results))
paste(names(bigraph_results), bigraph_results)
# keep only true positive overlaps
filter_overlap <- overlap_iou[paste(overlap_iou$detection.id, overlap_iou$reference.id) == paste(names(bigraph_results), bigraph_results), ]
# keep only true positive overlaps
filter_overlap <- overlap_iou[paste(overlap_iou$detection.id, overlap_iou$reference.id) %in% paste(names(bigraph_results), bigraph_results), ]
filter_overlap
source("~/Dropbox/R_package_testing/ohun/R/label_detection.R", echo=TRUE)
overlap_iou$detection.id %in%  ambiguous_detec$id
ambiguous_detec$id
# keep only true positive overlaps
filter_overlap <- overlap_iou[paste(overlap_iou$detection.id, overlap_iou$reference.id) %in% paste(names(bigraph_results), bigraph_results) | !overlap_iou$detection.id %in% ambiguous_detec$id, ]
filter_overlap
# keep only true positive overlaps
overlap_iou <- overlap_iou[paste(overlap_iou$detection.id, overlap_iou$reference.id) %in% paste(names(bigraph_results), bigraph_results) | !overlap_iou$detection.id %in% ambiguous_detec$id, ]
# get those that change to false positives
bigraph_false_positives <-
names(bigraph_results)[is.na(bigraph_results)]
if (length(bigraph_false_positives) > 0)
sub_detec$detection.class[paste(sub_detec$sound.files, sub_detec$selec, sep = "-") %in% bigraph_false_positives] <- gsub("true.positive", "negative", sub_detec$detection.class[paste(sub_detec$sound.files, sub_detec$selec, sep = "-") %in% bigraph_false_positives])
sub_detec$overlap <- vapply(seq_len(nrow(sub_detec)),
function(x){
ovlp <- overlap_iou$IoU[overlap_iou$detection.id == paste(sub_detec$sound.files[x], sub_detec$selec[x], sep = "-")]
if (length(ovlp) == 0) ovlp <- NA
return(ovlp)
},
FUN.VALUE = numeric(1))
source("~/Dropbox/R_package_testing/ohun/R/label_detection.R")
source("~/Dropbox/R_package_testing/ohun/R/summarize_diagnostic.R")
source("~/Dropbox/R_package_testing/ohun/R/label_detection.R")
ld <- label_detection(reference = reference, detection = detection, min.overlap = 0.01)
plot_detection(detection = ld, reference = reference, sep = 0.3)
diagnose_detection(reference = reference, detection = detection, by.sound.file = F, macro.average = F)
ld <- label_detection(reference = reference, detection = detection, min.overlap = 0.01)
plot_detection(detection = ld, reference = reference, sep = 0.3)
diagnose_detection(reference = reference, detection = detection, by.sound.file = F, macro.average = F)
source("~/Dropbox/R_package_testing/ohun/R/label_detection.R")
# system("autoconf  ")
# usethis::use_rcpp()
# setwd("./warbleR/")
#delete NAMESPACE file
# Rcpp::compileAttributes()
#run document twice
# devtools::document(".")
# devtools::load_all()
# usethis::use_coverage()
# pkgcheck::use_github_action_pkgcheck()
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# devtools::run_examples( start = "rm_sil")
# devtools::build_manual()
# devtools::install()
# check in R version 3.X.X
## run in terminal:
# /opt/R/3.6.3/bin/R
# devtools::check("~/Dropbox/R_package_testing/warbleR/warbleR", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# system("autoconf  ")
# usethis::use_rcpp()
# setwd("./warbleR/")
#delete NAMESPACE file
# Rcpp::compileAttributes()
#run document twice
# devtools::document(".")
# devtools::load_all()
# usethis::use_coverage()
# pkgcheck::use_github_action_pkgcheck()
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# devtools::run_examples( start = "rm_sil")
# devtools::build_manual()
# devtools::install()
# check in R version 3.X.X
## run in terminal:
# /opt/R/3.6.3/bin/R
# devtools::check("~/Dropbox/R_package_testing/warbleR/warbleR", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# system("autoconf  ")
# usethis::use_rcpp()
# setwd("./warbleR/")
#delete NAMESPACE file
# Rcpp::compileAttributes()
#run document twice
# devtools::document(".")
# devtools::load_all()
# usethis::use_coverage()
# pkgcheck::use_github_action_pkgcheck()
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# devtools::run_examples( start = "rm_sil")
# devtools::build_manual()
# devtools::install()
# check in R version 3.X.X
## run in terminal:
# /opt/R/3.6.3/bin/R
# devtools::check("~/Dropbox/R_package_testing/warbleR/warbleR", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
source("~/Dropbox/R_package_testing/ohun/R/label_detection.R")
styler::style_dir("./R")
# system("autoconf  ")
# usethis::use_rcpp()
# setwd("./warbleR/")
#delete NAMESPACE file
# Rcpp::compileAttributes()
#run document twice
# devtools::document(".")
# devtools::load_all()
# usethis::use_coverage()
# pkgcheck::use_github_action_pkgcheck()
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
# devtools::run_examples( start = "rm_sil")
# devtools::build_manual()
# devtools::install()
# check in R version 3.X.X
## run in terminal:
# /opt/R/3.6.3/bin/R
# devtools::check("~/Dropbox/R_package_testing/warbleR/warbleR", document = TRUE, run_dont_test = TRUE, vignettes = FALSE, manual = TRUE)
pkgdown::build_site()
# Chunk 2: global options
#load package
library(ohun)
load("../data/lbh2.rda")
remove.packages("ohun")
remotes::install_github("maRce10/ohun")
remotes::install_github("maRce10/ohun")
remotes::install_github("maRce10/ohun")
remotes::install_github("maRce10/ohun")
remotes::install_github("maRce10/ohun")
remotes::install_github("maRce10/ohun")
remotes::install_github("maRce10/ohun")
remotes::install_github("maRce10/ohun")
remotes::install_github("maRce10/ohun")
#load package
library(ohun)
remotes::install_github("maRce10/ohun")
